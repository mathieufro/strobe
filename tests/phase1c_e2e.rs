//! End-to-end tests for Phase 1c features: Crash Capture, Fork/Exec Following,
//! and Enhanced Queries.
//!
//! Architecture:
//! - Unit tests (DB, DWARF, query filters) run as normal `#[test]` — parallel, fast.
//! - Frida E2E tests run sequentially inside ONE `#[tokio::test]` orchestrator to
//!   avoid concurrent Frida sessions (GLib state is process-global and can't handle it).
//!
//! Requirements:
//! - stress_test_phase1c binary built with debug symbols (clang -g -O0)
//! - .dSYM bundle present (auto-generated by clang on macOS)

use std::path::PathBuf;
use std::time::{Duration, Instant};
use tempfile::tempdir;

/// Get the stress_test_phase1c binary path.
/// Returns None if the binary or dSYM doesn't exist.
fn phase1c_binary() -> Option<PathBuf> {
    let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests/stress_test_phase1c/stress_test_phase1c");
    let dsym = path.with_extension("dSYM");
    if path.exists() && dsym.exists() {
        Some(path)
    } else {
        eprintln!(
            "Skipping phase1c E2E test: binary={} dSYM={}",
            path.exists(),
            dsym.exists()
        );
        None
    }
}

/// Helper: create a SessionManager with a temp database.
fn create_session_manager() -> (strobe::daemon::SessionManager, tempfile::TempDir) {
    let dir = tempdir().unwrap();
    let db_path = dir.path().join("test.db");
    let sm = strobe::daemon::SessionManager::new(&db_path).unwrap();
    (sm, dir)
}

/// Poll the DB until `predicate` returns true, or timeout.
/// Polls every 100ms. Returns the events from the last query.
async fn poll_events(
    sm: &strobe::daemon::SessionManager,
    session_id: &str,
    timeout: Duration,
    predicate: impl Fn(&[strobe::db::Event]) -> bool,
) -> Vec<strobe::db::Event> {
    let start = Instant::now();
    loop {
        let events = sm.db().query_events(session_id, |q| q.limit(500)).unwrap();
        if predicate(&events) || start.elapsed() >= timeout {
            return events;
        }
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
}

/// Poll with a specific event type filter.
async fn poll_events_typed(
    sm: &strobe::daemon::SessionManager,
    session_id: &str,
    timeout: Duration,
    event_type: strobe::db::EventType,
    predicate: impl Fn(&[strobe::db::Event]) -> bool,
) -> Vec<strobe::db::Event> {
    let start = Instant::now();
    loop {
        let events = sm
            .db()
            .query_events(session_id, |q| q.event_type(event_type.clone()).limit(500))
            .unwrap();
        if predicate(&events) || start.elapsed() >= timeout {
            return events;
        }
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
}

// ═══════════════════════════════════════════════════════════════════════
// Frida E2E Orchestrator — runs all Frida scenarios sequentially
// ═══════════════════════════════════════════════════════════════════════

/// Single entry point for all Frida-based E2E tests.
/// Uses ONE SessionManager (= one FridaSpawner = one worker thread) to avoid
/// Frida/GLib teardown races between scenarios.
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_frida_e2e_scenarios() {
    let binary = match phase1c_binary() {
        Some(b) => b,
        None => return,
    };

    let (sm, _dir) = create_session_manager();
    let binary_str = binary.to_str().unwrap();
    let project_root = binary.parent().unwrap().to_str().unwrap();

    eprintln!("=== Scenario 1/6: crash capture (null deref) ===");
    scenario_crash_null_deref(&sm, binary_str, project_root).await;

    eprintln!("\n=== Scenario 2/6: crash capture (abort) ===");
    scenario_crash_abort(&sm, binary_str, project_root).await;

    eprintln!("\n=== Scenario 3/6: fork workers output ===");
    scenario_fork_workers(&sm, binary_str, project_root).await;

    eprintln!("\n=== Scenario 4/6: fork exec output ===");
    scenario_fork_exec(&sm, binary_str, project_root).await;

    eprintln!("\n=== Scenario 5/6: duration query ===");
    scenario_duration_query(&sm, binary_str, project_root).await;

    eprintln!("\n=== Scenario 6/6: output capture ===");
    scenario_output_capture(&sm, binary_str, project_root).await;

    eprintln!("\n=== All 6 Frida E2E scenarios passed ===");
}

// ─── Scenario: Crash Capture (null deref) ────────────────────────────

async fn scenario_crash_null_deref(
    sm: &strobe::daemon::SessionManager,
    binary_str: &str,
    project_root: &str,
) {
    let session_id = "crash-null-test";

    let pid = sm
        .spawn_with_frida(
            session_id,
            binary_str,
            &["crash-null".to_string()],
            None,
            project_root,
            None,
        )
        .await
        .unwrap();

    sm.create_session(session_id, binary_str, project_root, pid)
        .unwrap();

    assert!(pid > 0, "Should get a valid PID");

    // Poll until a crash event appears
    let all_events = poll_events(sm, session_id, Duration::from_secs(5), |events| {
        events
            .iter()
            .any(|e| e.event_type == strobe::db::EventType::Crash)
    })
    .await;

    eprintln!(
        "Total events: {} (types: {:?})",
        all_events.len(),
        all_events
            .iter()
            .map(|e| e.event_type.as_str())
            .collect::<Vec<_>>()
    );

    // Verify stdout captured before crash
    let stdout_events = sm
        .db()
        .query_events(session_id, |q| {
            q.event_type(strobe::db::EventType::Stdout)
        })
        .unwrap();

    let stdout_text: String = stdout_events
        .iter()
        .filter_map(|e| e.text.as_deref())
        .collect();

    assert!(
        stdout_text.contains("STRESS TEST 1C") || stdout_text.contains("CRASH"),
        "Should capture stdout before crash. Got: {}",
        stdout_text
    );

    // Verify crash event
    let crash_events = sm
        .db()
        .query_events(session_id, |q| {
            q.event_type(strobe::db::EventType::Crash)
        })
        .unwrap();

    assert!(
        !crash_events.is_empty(),
        "Should capture a crash event. Got events: {:?}",
        all_events
            .iter()
            .map(|e| e.event_type.as_str())
            .collect::<Vec<_>>()
    );

    let crash = &crash_events[0];

    // Signal
    assert!(crash.signal.is_some(), "Crash should have signal");
    let signal = crash.signal.as_ref().unwrap();
    eprintln!("Crash signal: {}", signal);
    assert!(
        signal.contains("access-violation") || signal.contains("abort") || signal.contains("SEGV"),
        "Signal should indicate crash: {}",
        signal
    );

    // Fault address
    assert!(crash.fault_address.is_some(), "Crash should have fault_address");
    let fault_addr = crash.fault_address.as_ref().unwrap();
    assert!(fault_addr.starts_with("0x"), "Fault address should be hex: {}", fault_addr);

    // Registers
    assert!(crash.registers.is_some(), "Crash should have registers");
    let reg_obj = crash.registers.as_ref().unwrap().as_object().unwrap();
    assert!(!reg_obj.is_empty(), "Should have registers captured");

    if cfg!(target_arch = "aarch64") {
        assert!(reg_obj.contains_key("pc"), "ARM64: missing pc");
        assert!(reg_obj.contains_key("sp"), "ARM64: missing sp");
        assert!(reg_obj.contains_key("fp"), "ARM64: missing fp");
    } else {
        assert!(reg_obj.contains_key("rip"), "x86_64: missing rip");
        assert!(reg_obj.contains_key("rsp"), "x86_64: missing rsp");
    }

    // Backtrace
    assert!(crash.backtrace.is_some(), "Crash should have backtrace");
    let frames = crash.backtrace.as_ref().unwrap().as_array().unwrap();
    eprintln!("Backtrace: {} frames", frames.len());
    assert!(!frames.is_empty(), "Backtrace should have frames");
    assert!(frames[0].get("address").is_some(), "First frame should have address");

    let has_crash_symbol = frames.iter().any(|f| {
        f.get("name")
            .and_then(|n| n.as_str())
            .map(|s| s.contains("crash_null_deref"))
            .unwrap_or(false)
    });
    if has_crash_symbol {
        eprintln!("Found crash_null_deref in backtrace");
    }

    // PID
    assert_eq!(crash.pid, Some(pid), "Crash PID should match");

    let _ = sm.stop_session(session_id);
}

// ─── Scenario: Crash Capture (abort) ─────────────────────────────────

async fn scenario_crash_abort(
    sm: &strobe::daemon::SessionManager,
    binary_str: &str,
    project_root: &str,
) {
    let session_id = "crash-abort-test";

    let pid = sm
        .spawn_with_frida(
            session_id,
            binary_str,
            &["crash-abort".to_string()],
            None,
            project_root,
            None,
        )
        .await
        .unwrap();

    sm.create_session(session_id, binary_str, project_root, pid)
        .unwrap();

    // Poll until crash or stdout appears
    let all_events = poll_events(sm, session_id, Duration::from_secs(5), |events| {
        events.iter().any(|e| {
            e.event_type == strobe::db::EventType::Crash
                || e.event_type == strobe::db::EventType::Stdout
        })
    })
    .await;

    let crash_events: Vec<_> = all_events
        .iter()
        .filter(|e| e.event_type == strobe::db::EventType::Crash)
        .collect();

    // abort() may not be catchable by Frida on all macOS versions
    if let Some(crash) = crash_events.first() {
        let signal = crash.signal.as_ref().unwrap();
        eprintln!("Abort signal: {}", signal);
        assert!(
            signal.contains("abort")
                || signal.contains("ABRT")
                || signal.contains("access-violation"),
            "Signal should indicate abort: {}",
            signal
        );
    } else {
        eprintln!("Note: abort() not captured by Frida exception handler (expected on some macOS)");
        let stdout_text: String = all_events
            .iter()
            .filter(|e| e.event_type == strobe::db::EventType::Stdout)
            .filter_map(|e| e.text.as_deref())
            .collect();
        assert!(
            stdout_text.contains("About to abort") || stdout_text.contains("STRESS TEST 1C"),
            "Should at least capture stdout before abort. Got: {}",
            stdout_text
        );
    }

    let _ = sm.stop_session(session_id);
}

// ─── Scenario: Fork Workers ──────────────────────────────────────────

async fn scenario_fork_workers(
    sm: &strobe::daemon::SessionManager,
    binary_str: &str,
    project_root: &str,
) {
    let session_id = "fork-workers-test";

    let pid = sm
        .spawn_with_frida(
            session_id,
            binary_str,
            &["fork-workers".to_string()],
            None,
            project_root,
            None,
        )
        .await
        .unwrap();

    sm.create_session(session_id, binary_str, project_root, pid)
        .unwrap();

    // Poll until parent finishes waiting for children
    let stdout_events = poll_events_typed(
        sm,
        session_id,
        Duration::from_secs(10),
        strobe::db::EventType::Stdout,
        |events| {
            let text: String = events.iter().filter_map(|e| e.text.as_deref()).collect();
            text.contains("exited with status")
        },
    )
    .await;

    let all_stdout: String = stdout_events
        .iter()
        .filter_map(|e| e.text.as_deref())
        .collect();

    eprintln!("Fork stdout ({} events):\n{}", stdout_events.len(), all_stdout);

    assert!(
        all_stdout.contains("PARENT"),
        "Should capture parent stdout. Got: {}",
        all_stdout
    );
    assert!(
        all_stdout.contains("PID="),
        "Should see PID info. Got: {}",
        all_stdout
    );

    let has_child_output = all_stdout.contains("CHILD");
    if has_child_output {
        eprintln!("Child process output captured — fork following working!");
    } else {
        eprintln!("Note: Child output not captured (may be expected without spawn gating)");
    }

    let all_pids = sm.get_all_pids(session_id);
    eprintln!("PIDs in session: {:?}", all_pids);
    assert!(all_pids.contains(&pid), "Session should contain parent PID {}", pid);

    if all_pids.len() > 1 {
        eprintln!("Multi-PID session: {} PIDs (fork following confirmed)", all_pids.len());
    }

    let _ = sm.stop_session(session_id);
}

// ─── Scenario: Fork Exec ─────────────────────────────────────────────

async fn scenario_fork_exec(
    sm: &strobe::daemon::SessionManager,
    binary_str: &str,
    project_root: &str,
) {
    let session_id = "fork-exec-test";

    let pid = sm
        .spawn_with_frida(
            session_id,
            binary_str,
            &["fork-exec".to_string()],
            None,
            project_root,
            None,
        )
        .await
        .unwrap();

    sm.create_session(session_id, binary_str, project_root, pid)
        .unwrap();

    // Poll until parent reports child exit
    let stdout_events = poll_events_typed(
        sm,
        session_id,
        Duration::from_secs(5),
        strobe::db::EventType::Stdout,
        |events| {
            let text: String = events.iter().filter_map(|e| e.text.as_deref()).collect();
            text.contains("exited with status")
        },
    )
    .await;

    let all_stdout: String = stdout_events
        .iter()
        .filter_map(|e| e.text.as_deref())
        .collect();

    eprintln!("Fork-exec stdout:\n{}", all_stdout);

    assert!(
        all_stdout.contains("PARENT") || all_stdout.contains("fork"),
        "Should capture parent output"
    );

    let _ = sm.stop_session(session_id);
}

// ─── Scenario: Duration Query ────────────────────────────────────────

async fn scenario_duration_query(
    sm: &strobe::daemon::SessionManager,
    binary_str: &str,
    project_root: &str,
) {
    let session_id = "duration-query-test";

    let pid = sm
        .spawn_with_frida(
            session_id,
            binary_str,
            &["slow-functions".to_string()],
            None,
            project_root,
            None,
        )
        .await
        .unwrap();

    sm.create_session(session_id, binary_str, project_root, pid)
        .unwrap();

    // Add trace patterns for timing functions
    sm.add_patterns(
        session_id,
        &[
            "fast_function".to_string(),
            "medium_function".to_string(),
            "slow_function".to_string(),
            "very_slow_function".to_string(),
            "run_slow_functions".to_string(),
        ],
    )
    .unwrap();

    let hook_result = sm
        .update_frida_patterns(
            session_id,
            Some(&[
                "fast_function".to_string(),
                "medium_function".to_string(),
                "slow_function".to_string(),
                "very_slow_function".to_string(),
                "run_slow_functions".to_string(),
            ]),
            None,
            None,
        )
        .await;

    match &hook_result {
        Ok(r) => eprintln!("Hooked {} functions (matched: {})", r.installed, r.matched),
        Err(e) => {
            eprintln!("Warning: hook install failed: {}. Process may have exited.", e);
            return;
        }
    }

    let hook_result = hook_result.unwrap();
    if hook_result.installed == 0 {
        eprintln!("No functions hooked — process may have exited or patterns didn't match.");
        return;
    }

    // Poll until we see function_exit events with a slow one (>= 40ms)
    let exit_events = poll_events_typed(
        sm,
        session_id,
        Duration::from_secs(10),
        strobe::db::EventType::FunctionExit,
        |events| {
            events
                .iter()
                .any(|e| e.duration_ns.unwrap_or(0) >= 40_000_000)
        },
    )
    .await;

    eprintln!("Function exit events: {}", exit_events.len());
    for e in &exit_events {
        eprintln!(
            "  {} duration={}ms",
            e.function_name,
            e.duration_ns.unwrap_or(0) as f64 / 1_000_000.0
        );
    }

    if exit_events.is_empty() {
        eprintln!("No function exit events. Process may have completed before hooks.");
        return;
    }

    // Test min_duration_ns filter: >= 40ms should get slow + very_slow
    let slow_events = sm
        .db()
        .query_events(session_id, |q| {
            let mut q = q
                .event_type(strobe::db::EventType::FunctionExit)
                .limit(500);
            q.min_duration_ns = Some(40_000_000);
            q
        })
        .unwrap();

    eprintln!("Events with duration >= 40ms: {}", slow_events.len());
    for e in &slow_events {
        let dur_ms = e.duration_ns.unwrap_or(0) as f64 / 1_000_000.0;
        eprintln!("  {} = {:.1}ms", e.function_name, dur_ms);
        assert!(
            e.duration_ns.unwrap_or(0) >= 40_000_000,
            "Filtered event {} should have duration >= 40ms, got {:.1}ms",
            e.function_name,
            dur_ms
        );
    }

    let fast_in_slow = slow_events
        .iter()
        .any(|e| e.function_name.contains("fast_function"));
    assert!(!fast_in_slow, "fast_function should not appear in >= 40ms filter");

    // Test time range filter
    if exit_events.len() >= 2 {
        let first_ts = exit_events[0].timestamp_ns;
        let last_ts = exit_events[exit_events.len() - 1].timestamp_ns;

        let time_filtered = sm
            .db()
            .query_events(session_id, |q| {
                let mut q = q
                    .event_type(strobe::db::EventType::FunctionExit)
                    .limit(500);
                q.timestamp_from_ns = Some(first_ts + 1);
                q.timestamp_to_ns = Some(last_ts);
                q
            })
            .unwrap();

        assert!(
            time_filtered.len() < exit_events.len(),
            "Time-filtered query should return fewer events"
        );
    }

    let _ = sm.stop_session(session_id);
}

// ─── Scenario: Output Capture ────────────────────────────────────────

async fn scenario_output_capture(
    sm: &strobe::daemon::SessionManager,
    binary_str: &str,
    project_root: &str,
) {
    let session_id = "output-test";

    let pid = sm
        .spawn_with_frida(
            session_id,
            binary_str,
            &["slow-functions".to_string()],
            None,
            project_root,
            None,
        )
        .await
        .unwrap();

    sm.create_session(session_id, binary_str, project_root, pid)
        .unwrap();

    // Poll until the program prints "Done"
    let stdout_events = poll_events_typed(
        sm,
        session_id,
        Duration::from_secs(10),
        strobe::db::EventType::Stdout,
        |events| {
            let text: String = events.iter().filter_map(|e| e.text.as_deref()).collect();
            text.contains("Done")
        },
    )
    .await;

    let all_stdout: String = stdout_events
        .iter()
        .filter_map(|e| e.text.as_deref())
        .collect();

    eprintln!("Output capture ({} events):\n{}", stdout_events.len(), all_stdout);

    assert!(!stdout_events.is_empty(), "Should capture stdout events");
    assert!(all_stdout.contains("STRESS TEST 1C"), "Should capture startup message");
    assert!(all_stdout.contains("TIMING"), "Should capture timing output");
    assert!(all_stdout.contains("slow_function"), "Should see slow_function output");

    // Verify PID on stdout events
    for event in &stdout_events {
        assert!(event.pid.is_some(), "Stdout events should have PID");
        assert_eq!(event.pid.unwrap(), pid, "Stdout PID should match");
    }

    let _ = sm.stop_session(session_id);
}

// ═══════════════════════════════════════════════════════════════════════
// Unit Tests — DB round-trip, DWARF parsing, query filters
// ═══════════════════════════════════════════════════════════════════════

/// Insert a crash event with realistic field values and verify all fields
/// survive the DB round-trip.
#[test]
fn test_crash_event_db_roundtrip_with_real_data() {
    let dir = tempdir().unwrap();
    let db = strobe::db::Database::open(&dir.path().join("test.db")).unwrap();
    db.create_session("s1", "/bin/test", "/tmp", 1234).unwrap();

    let registers = serde_json::json!({
        "x0": "0x0",
        "x1": "0x16f603e30",
        "x2": "0x2a",
        "fp": "0x16f604000",
        "lr": "0x100003f48",
        "sp": "0x16f603e00",
        "pc": "0x100003f20"
    });

    let backtrace = serde_json::json!([
        {
            "address": "0x100003f20",
            "moduleName": "stress_test_phase1c",
            "name": "crash_null_deref",
            "fileName": "/Users/alex/strobe/tests/stress_test_phase1c/main.c",
            "lineNumber": 30
        },
        {
            "address": "0x100004100",
            "moduleName": "stress_test_phase1c",
            "name": "main",
            "fileName": "/Users/alex/strobe/tests/stress_test_phase1c/main.c",
            "lineNumber": 180
        }
    ]);

    let locals = serde_json::json!([
        { "name": "local_counter", "value": "42", "type": "int" },
        { "name": "local_ratio", "value": "3.14159", "type": "float" },
        { "name": "ptr", "value": "0x0", "type": "int *" }
    ]);

    let crash_event = strobe::db::Event {
        id: "crash-evt-1".to_string(),
        session_id: "s1".to_string(),
        timestamp_ns: 1000000,
        thread_id: 1,
        thread_name: Some("main".to_string()),
        parent_event_id: None,
        event_type: strobe::db::EventType::Crash,
        function_name: "crash_null_deref".to_string(),
        function_name_raw: None,
        source_file: Some("/Users/alex/strobe/tests/stress_test_phase1c/main.c".to_string()),
        line_number: Some(30),
        arguments: None,
        return_value: None,
        duration_ns: None,
        text: None,
        sampled: None,
        watch_values: None,
        pid: Some(1234),
        signal: Some("access-violation".to_string()),
        fault_address: Some("0x0".to_string()),
        registers: Some(registers.clone()),
        backtrace: Some(backtrace.clone()),
        locals: Some(locals.clone()),
    };

    db.insert_event(crash_event).unwrap();

    let events = db
        .query_events("s1", |q| q.event_type(strobe::db::EventType::Crash))
        .unwrap();

    assert_eq!(events.len(), 1);
    let e = &events[0];

    assert_eq!(e.event_type, strobe::db::EventType::Crash);
    assert_eq!(e.signal.as_deref(), Some("access-violation"));
    assert_eq!(e.fault_address.as_deref(), Some("0x0"));
    assert_eq!(e.pid, Some(1234));

    let stored_regs = e.registers.as_ref().unwrap();
    assert_eq!(stored_regs["pc"], "0x100003f20");
    assert_eq!(stored_regs["fp"], "0x16f604000");
    assert_eq!(stored_regs["x0"], "0x0");

    let stored_bt = e.backtrace.as_ref().unwrap();
    let frames = stored_bt.as_array().unwrap();
    assert_eq!(frames.len(), 2);
    assert_eq!(frames[0]["name"], "crash_null_deref");
    assert_eq!(frames[1]["name"], "main");

    let stored_locals = e.locals.as_ref().unwrap();
    let local_arr = stored_locals.as_array().unwrap();
    assert_eq!(local_arr.len(), 3);
    assert_eq!(local_arr[0]["name"], "local_counter");
    assert_eq!(local_arr[2]["value"], "0x0");
}

/// Verify crash events work in unified timeline alongside normal events.
#[test]
fn test_crash_event_in_unified_timeline() {
    let dir = tempdir().unwrap();
    let db = strobe::db::Database::open(&dir.path().join("test.db")).unwrap();
    db.create_session("s1", "/bin/test", "/tmp", 1234).unwrap();

    db.insert_event(strobe::db::Event {
        id: "evt-1".to_string(),
        session_id: "s1".to_string(),
        timestamp_ns: 1000,
        thread_id: 1,
        thread_name: None,
        parent_event_id: None,
        event_type: strobe::db::EventType::Stdout,
        function_name: String::new(),
        function_name_raw: None,
        source_file: None,
        line_number: None,
        arguments: None,
        return_value: None,
        duration_ns: None,
        text: Some("About to crash\n".to_string()),
        sampled: None,
        watch_values: None,
        pid: Some(1234),
        signal: None,
        fault_address: None,
        registers: None,
        backtrace: None,
        locals: None,
    })
    .unwrap();

    db.insert_event(strobe::db::Event {
        id: "evt-2".to_string(),
        session_id: "s1".to_string(),
        timestamp_ns: 2000,
        thread_id: 1,
        thread_name: None,
        parent_event_id: None,
        event_type: strobe::db::EventType::FunctionEnter,
        function_name: "crash_null_deref".to_string(),
        function_name_raw: None,
        source_file: Some("main.c".to_string()),
        line_number: Some(16),
        arguments: None,
        return_value: None,
        duration_ns: None,
        text: None,
        sampled: None,
        watch_values: None,
        pid: Some(1234),
        signal: None,
        fault_address: None,
        registers: None,
        backtrace: None,
        locals: None,
    })
    .unwrap();

    db.insert_event(strobe::db::Event {
        id: "evt-3".to_string(),
        session_id: "s1".to_string(),
        timestamp_ns: 3000,
        thread_id: 1,
        thread_name: None,
        parent_event_id: None,
        event_type: strobe::db::EventType::Crash,
        function_name: "crash_null_deref".to_string(),
        function_name_raw: None,
        source_file: Some("main.c".to_string()),
        line_number: Some(30),
        arguments: None,
        return_value: None,
        duration_ns: None,
        text: None,
        sampled: None,
        watch_values: None,
        pid: Some(1234),
        signal: Some("access-violation".to_string()),
        fault_address: Some("0x0".to_string()),
        registers: Some(serde_json::json!({"pc": "0x100003f20"})),
        backtrace: Some(
            serde_json::json!([{"address": "0x100003f20", "name": "crash_null_deref"}]),
        ),
        locals: None,
    })
    .unwrap();

    let all = db.query_events("s1", |q| q).unwrap();
    assert_eq!(all.len(), 3);
    assert_eq!(all[0].event_type, strobe::db::EventType::Stdout);
    assert_eq!(all[1].event_type, strobe::db::EventType::FunctionEnter);
    assert_eq!(all[2].event_type, strobe::db::EventType::Crash);

    let crashes = db
        .query_events("s1", |q| q.event_type(strobe::db::EventType::Crash))
        .unwrap();
    assert_eq!(crashes.len(), 1);
    assert_eq!(crashes[0].signal.as_deref(), Some("access-violation"));

    let pid_events = db
        .query_events("s1", |q| {
            let mut q = q;
            q.pid_equals = Some(1234);
            q
        })
        .unwrap();
    assert_eq!(pid_events.len(), 3);

    let wrong_pid = db
        .query_events("s1", |q| {
            let mut q = q;
            q.pid_equals = Some(9999);
            q
        })
        .unwrap();
    assert_eq!(wrong_pid.len(), 0);
}

/// Parse the phase1c binary DWARF info and verify local variables.
#[test]
fn test_dwarf_locals_parsing_phase1c_binary() {
    let binary = match phase1c_binary() {
        Some(b) => b,
        None => return,
    };

    let parser = strobe::dwarf::DwarfParser::parse(&binary).unwrap();

    let funcs = parser.find_by_pattern("crash_null_deref");
    assert!(!funcs.is_empty(), "Should find crash_null_deref in DWARF");

    let crash_fn = &funcs[0];
    assert!(
        crash_fn
            .source_file
            .as_ref()
            .map(|f| f.contains("main.c"))
            .unwrap_or(false),
        "crash_null_deref should be in main.c"
    );

    let mid_pc = crash_fn.low_pc + (crash_fn.high_pc - crash_fn.low_pc) / 2;
    match parser.parse_locals_at_pc(mid_pc) {
        Ok(locals) => {
            eprintln!("Locals at PC 0x{:x}: {:?}", mid_pc, locals.iter().map(|l| &l.name).collect::<Vec<_>>());
            assert!(!locals.is_empty(), "Should find locals in crash_null_deref");
        }
        Err(e) => {
            eprintln!("parse_locals_at_pc failed: {} (may need location lists)", e);
        }
    }
}

/// Test resolve_crash_locals with synthetic frame data.
#[test]
fn test_resolve_crash_locals_synthetic() {
    use strobe::dwarf::{LocalVarLocation, LocalVariableInfo, TypeKind};

    let locals = vec![
        LocalVariableInfo {
            name: "local_counter".to_string(),
            byte_size: 4,
            type_kind: TypeKind::Integer { signed: true },
            type_name: Some("int".to_string()),
            location: LocalVarLocation::FrameBaseRelative(-8),
        },
        LocalVariableInfo {
            name: "local_ratio".to_string(),
            byte_size: 4,
            type_kind: TypeKind::Float,
            type_name: Some("float".to_string()),
            location: LocalVarLocation::FrameBaseRelative(-16),
        },
        LocalVariableInfo {
            name: "ptr".to_string(),
            byte_size: 8,
            type_kind: TypeKind::Pointer,
            type_name: Some("int *".to_string()),
            location: LocalVarLocation::FrameBaseRelative(-24),
        },
    ];

    let fp: u64 = 0x1000;
    let frame_start = fp - 512;

    let mut frame_bytes = vec![0u8; 640];

    // local_counter at fp-8: value 42
    let counter_offset = (fp - 8 - frame_start) as usize;
    frame_bytes[counter_offset] = 42;

    // local_ratio at fp-16: value 3.14159f32
    let ratio_offset = (fp - 16 - frame_start) as usize;
    let ratio_bits = 3.14159f32.to_bits();
    frame_bytes[ratio_offset] = (ratio_bits & 0xFF) as u8;
    frame_bytes[ratio_offset + 1] = ((ratio_bits >> 8) & 0xFF) as u8;
    frame_bytes[ratio_offset + 2] = ((ratio_bits >> 16) & 0xFF) as u8;
    frame_bytes[ratio_offset + 3] = ((ratio_bits >> 24) & 0xFF) as u8;

    // ptr at fp-24: value 0x0 (null)
    // already zeroed

    let frame_hex: String = frame_bytes.iter().map(|b| format!("{:02x}", b)).collect();
    let frame_base = format!("0x{:x}", fp);

    let registers = serde_json::json!({
        "fp": frame_base,
        "sp": "0x0e00",
        "pc": "0x100003f20",
    });

    let result = strobe::dwarf::resolve_crash_locals(
        &locals,
        &registers,
        Some(&frame_hex),
        Some(&frame_base),
        "arm64",
    );

    assert_eq!(result.len(), 3, "Should resolve all 3 locals");

    assert_eq!(result[0]["name"], "local_counter");
    assert_eq!(result[0]["value"], "0x2a");

    let ratio_hex = result[1]["value"].as_str().unwrap();
    let ratio_val = f32::from_bits(
        u32::from_str_radix(ratio_hex.trim_start_matches("0x"), 16).unwrap(),
    );
    assert!(
        (ratio_val - 3.14159).abs() < 0.001,
        "local_ratio should be ~3.14159, got {}",
        ratio_val
    );

    assert_eq!(result[2]["name"], "ptr");
    assert_eq!(result[2]["value"], "0x0");
}

/// Test resolve_crash_locals with register-based variable.
#[test]
fn test_resolve_crash_locals_register_based() {
    use strobe::dwarf::{LocalVarLocation, LocalVariableInfo, TypeKind};

    let locals = vec![LocalVariableInfo {
        name: "error_code".to_string(),
        byte_size: 4,
        type_kind: TypeKind::Integer { signed: true },
        type_name: Some("int".to_string()),
        location: LocalVarLocation::Register(0), // x0 on ARM64
    }];

    let registers = serde_json::json!({
        "x0": "0xffffffff",
        "fp": "0x1000",
        "sp": "0x0e00",
    });

    let result =
        strobe::dwarf::resolve_crash_locals(&locals, &registers, None, Some("0x1000"), "arm64");

    assert_eq!(result.len(), 1);
    assert_eq!(result[0]["name"], "error_code");
    assert_eq!(result[0]["value"], "-1"); // 0xffffffff as i32
}

/// Test pid_equals filter on EventQuery.
#[test]
fn test_pid_filter_on_events() {
    let dir = tempdir().unwrap();
    let db = strobe::db::Database::open(&dir.path().join("test.db")).unwrap();
    db.create_session("s1", "/bin/test", "/tmp", 1234).unwrap();

    for (i, pid_val) in [1234u32, 1234, 5678, 5678, 9999].iter().enumerate() {
        db.insert_event(strobe::db::Event {
            id: format!("evt-{}", i),
            session_id: "s1".to_string(),
            timestamp_ns: i as i64 * 1000,
            thread_id: 1,
            thread_name: None,
            parent_event_id: None,
            event_type: strobe::db::EventType::FunctionEnter,
            function_name: format!("func_{}", pid_val),
            function_name_raw: None,
            source_file: None,
            line_number: None,
            arguments: None,
            return_value: None,
            duration_ns: None,
            text: None,
            sampled: None,
            watch_values: None,
            pid: Some(*pid_val),
            signal: None,
            fault_address: None,
            registers: None,
            backtrace: None,
            locals: None,
        })
        .unwrap();
    }

    let pid_1234 = db
        .query_events("s1", |q| {
            let mut q = q;
            q.pid_equals = Some(1234);
            q
        })
        .unwrap();
    assert_eq!(pid_1234.len(), 2);

    let pid_5678 = db
        .query_events("s1", |q| {
            let mut q = q;
            q.pid_equals = Some(5678);
            q
        })
        .unwrap();
    assert_eq!(pid_5678.len(), 2);

    let pid_9999 = db
        .query_events("s1", |q| {
            let mut q = q;
            q.pid_equals = Some(9999);
            q
        })
        .unwrap();
    assert_eq!(pid_9999.len(), 1);

    let no_pid = db
        .query_events("s1", |q| {
            let mut q = q;
            q.pid_equals = Some(11111);
            q
        })
        .unwrap();
    assert_eq!(no_pid.len(), 0);
}

/// Test min_duration_ns filter.
#[test]
fn test_min_duration_filter() {
    let dir = tempdir().unwrap();
    let db = strobe::db::Database::open(&dir.path().join("test.db")).unwrap();
    db.create_session("s1", "/bin/test", "/tmp", 1234).unwrap();

    let durations: Vec<(&str, i64)> = vec![
        ("fast_func", 100_000),
        ("medium_func", 5_000_000),
        ("slow_func", 50_000_000),
        ("very_slow_func", 500_000_000),
    ];

    for (i, (name, duration)) in durations.iter().enumerate() {
        db.insert_event(strobe::db::Event {
            id: format!("evt-{}", i),
            session_id: "s1".to_string(),
            timestamp_ns: i as i64 * 1_000_000,
            thread_id: 1,
            thread_name: None,
            parent_event_id: None,
            event_type: strobe::db::EventType::FunctionExit,
            function_name: name.to_string(),
            function_name_raw: None,
            source_file: None,
            line_number: None,
            arguments: None,
            return_value: None,
            duration_ns: Some(*duration),
            text: None,
            sampled: None,
            watch_values: None,
            pid: None,
            signal: None,
            fault_address: None,
            registers: None,
            backtrace: None,
            locals: None,
        })
        .unwrap();
    }

    let ge_1ms = db
        .query_events("s1", |q| {
            let mut q = q;
            q.min_duration_ns = Some(1_000_000);
            q
        })
        .unwrap();
    assert_eq!(ge_1ms.len(), 3, "3 events >= 1ms");

    let ge_10ms = db
        .query_events("s1", |q| {
            let mut q = q;
            q.min_duration_ns = Some(10_000_000);
            q
        })
        .unwrap();
    assert_eq!(ge_10ms.len(), 2, "2 events >= 10ms");

    let ge_100ms = db
        .query_events("s1", |q| {
            let mut q = q;
            q.min_duration_ns = Some(100_000_000);
            q
        })
        .unwrap();
    assert_eq!(ge_100ms.len(), 1, "1 event >= 100ms");
    assert_eq!(ge_100ms[0].function_name, "very_slow_func");

    let ge_1s = db
        .query_events("s1", |q| {
            let mut q = q;
            q.min_duration_ns = Some(1_000_000_000);
            q
        })
        .unwrap();
    assert_eq!(ge_1s.len(), 0, "No events >= 1s");
}

/// Test time range filtering.
#[test]
fn test_time_range_filter() {
    let dir = tempdir().unwrap();
    let db = strobe::db::Database::open(&dir.path().join("test.db")).unwrap();
    db.create_session("s1", "/bin/test", "/tmp", 1234).unwrap();

    for i in 0..10 {
        db.insert_event(strobe::db::Event {
            id: format!("evt-{}", i),
            session_id: "s1".to_string(),
            timestamp_ns: (i + 1) * 1_000_000_000,
            thread_id: 1,
            thread_name: None,
            parent_event_id: None,
            event_type: strobe::db::EventType::FunctionEnter,
            function_name: format!("func_{}", i),
            function_name_raw: None,
            source_file: None,
            line_number: None,
            arguments: None,
            return_value: None,
            duration_ns: None,
            text: None,
            sampled: None,
            watch_values: None,
            pid: None,
            signal: None,
            fault_address: None,
            registers: None,
            backtrace: None,
            locals: None,
        })
        .unwrap();
    }

    let range = db
        .query_events("s1", |q| {
            let mut q = q;
            q.timestamp_from_ns = Some(3_000_000_000);
            q.timestamp_to_ns = Some(7_000_000_000);
            q
        })
        .unwrap();
    assert_eq!(range.len(), 5);
    assert_eq!(range[0].timestamp_ns, 3_000_000_000);
    assert_eq!(range[4].timestamp_ns, 7_000_000_000);

    let from_8s = db
        .query_events("s1", |q| {
            let mut q = q;
            q.timestamp_from_ns = Some(8_000_000_000);
            q
        })
        .unwrap();
    assert_eq!(from_8s.len(), 3);

    let to_2s = db
        .query_events("s1", |q| {
            let mut q = q;
            q.timestamp_to_ns = Some(2_000_000_000);
            q
        })
        .unwrap();
    assert_eq!(to_2s.len(), 2);
}

/// Test batch insert with crash events preserves all fields.
#[test]
fn test_batch_insert_with_crash_events() {
    let dir = tempdir().unwrap();
    let db = strobe::db::Database::open(&dir.path().join("test.db")).unwrap();
    db.create_session("s1", "/bin/test", "/tmp", 1234).unwrap();

    let events = vec![
        strobe::db::Event {
            id: "batch-1".to_string(),
            session_id: "s1".to_string(),
            timestamp_ns: 1000,
            thread_id: 1,
            thread_name: None,
            parent_event_id: None,
            event_type: strobe::db::EventType::FunctionEnter,
            function_name: "pre_crash_func".to_string(),
            function_name_raw: None,
            source_file: None,
            line_number: None,
            arguments: None,
            return_value: None,
            duration_ns: None,
            text: None,
            sampled: None,
            watch_values: None,
            pid: Some(1234),
            signal: None,
            fault_address: None,
            registers: None,
            backtrace: None,
            locals: None,
        },
        strobe::db::Event {
            id: "batch-2".to_string(),
            session_id: "s1".to_string(),
            timestamp_ns: 2000,
            thread_id: 1,
            thread_name: None,
            parent_event_id: None,
            event_type: strobe::db::EventType::Crash,
            function_name: "crash_func".to_string(),
            function_name_raw: None,
            source_file: Some("main.c".to_string()),
            line_number: Some(30),
            arguments: None,
            return_value: None,
            duration_ns: None,
            text: None,
            sampled: None,
            watch_values: None,
            pid: Some(1234),
            signal: Some("access-violation".to_string()),
            fault_address: Some("0x0".to_string()),
            registers: Some(serde_json::json!({"pc": "0xDEAD", "sp": "0xBEEF"})),
            backtrace: Some(
                serde_json::json!([{"address": "0xDEAD", "name": "crash_func"}]),
            ),
            locals: Some(serde_json::json!([{"name": "x", "value": "42", "type": "int"}])),
        },
    ];

    db.insert_events_batch(&events).unwrap();

    let results = db.query_events("s1", |q| q).unwrap();
    assert_eq!(results.len(), 2);

    assert_eq!(results[0].event_type, strobe::db::EventType::FunctionEnter);
    assert!(results[0].signal.is_none());

    let crash = &results[1];
    assert_eq!(crash.event_type, strobe::db::EventType::Crash);
    assert_eq!(crash.signal.as_deref(), Some("access-violation"));
    assert_eq!(crash.fault_address.as_deref(), Some("0x0"));
    assert_eq!(crash.registers.as_ref().unwrap()["pc"], "0xDEAD");
    assert_eq!(crash.backtrace.as_ref().unwrap()[0]["name"], "crash_func");
    assert_eq!(crash.locals.as_ref().unwrap()[0]["value"], "42");
}

/// Test update_event_locals modifies an existing crash event.
#[test]
fn test_update_event_locals() {
    let dir = tempdir().unwrap();
    let db = strobe::db::Database::open(&dir.path().join("test.db")).unwrap();
    db.create_session("s1", "/bin/test", "/tmp", 1234).unwrap();

    db.insert_event(strobe::db::Event {
        id: "crash-1".to_string(),
        session_id: "s1".to_string(),
        timestamp_ns: 1000,
        thread_id: 1,
        thread_name: None,
        parent_event_id: None,
        event_type: strobe::db::EventType::Crash,
        function_name: "crash_func".to_string(),
        function_name_raw: None,
        source_file: None,
        line_number: None,
        arguments: None,
        return_value: None,
        duration_ns: None,
        text: None,
        sampled: None,
        watch_values: None,
        pid: Some(1234),
        signal: Some("access-violation".to_string()),
        fault_address: Some("0x0".to_string()),
        registers: None,
        backtrace: None,
        locals: None,
    })
    .unwrap();

    let events = db.query_events("s1", |q| q).unwrap();
    assert!(events[0].locals.is_none());

    let locals = serde_json::json!([
        {"name": "counter", "value": "42", "type": "int"},
        {"name": "ratio", "value": "3.14", "type": "float"}
    ]);
    db.update_event_locals("crash-1", &locals).unwrap();

    let events = db.query_events("s1", |q| q).unwrap();
    let stored_locals = events[0].locals.as_ref().unwrap();
    let arr = stored_locals.as_array().unwrap();
    assert_eq!(arr.len(), 2);
    assert_eq!(arr[0]["name"], "counter");
    assert_eq!(arr[1]["name"], "ratio");
}

/// Verify DWARF parsing finds key functions in the phase1c C binary.
#[test]
fn test_dwarf_phase1c_function_discovery() {
    let binary = match phase1c_binary() {
        Some(b) => b,
        None => return,
    };

    let parser = strobe::dwarf::DwarfParser::parse(&binary).unwrap();

    eprintln!(
        "Phase1c: {} functions, {} variables",
        parser.functions.len(),
        parser.variables.len()
    );
    assert!(parser.functions.len() > 0);

    let expected_funcs = vec![
        "crash_null_deref",
        "crash_abort",
        "crash_stack_overflow",
        "do_child_work",
        "fork_workers",
        "fork_exec",
        "fast_function",
        "medium_function",
        "slow_function",
        "very_slow_function",
        "run_slow_functions",
        "main",
    ];

    for name in &expected_funcs {
        let matches = parser.find_by_pattern(name);
        assert!(
            !matches.is_empty(),
            "Should find '{}' in DWARF. Available: {:?}",
            name,
            parser
                .functions
                .iter()
                .filter(|f| f
                    .source_file
                    .as_ref()
                    .map(|s| s.contains("main.c"))
                    .unwrap_or(false))
                .map(|f| &f.name)
                .collect::<Vec<_>>()
        );
    }

    let main_c_funcs = parser.find_by_source_file("main.c");
    assert!(
        main_c_funcs.len() >= expected_funcs.len(),
        "@file:main.c should find >= {} functions, found {}",
        expected_funcs.len(),
        main_c_funcs.len()
    );

    let expected_vars = vec!["g_crash_count", "g_temperature", "g_app_state"];
    for name in &expected_vars {
        let found = parser.variables.iter().any(|v| v.name.contains(name));
        if found {
            eprintln!("Found global: {}", name);
        } else {
            eprintln!("Warning: global '{}' not found", name);
        }
    }
}
